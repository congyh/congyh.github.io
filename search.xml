<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F08%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(未完成)MongoDB知识点汇总]]></title>
      <url>%2F2016%2F12%2F08%2Finterview-mongo%2F</url>
      <content type="text"><![CDATA[MongoDB适用场景 日志 每个应用环境都有不同的日志信息, 文档型数据库没有固定的模式, 很适合用来存储日志. (TODO 待补充) MongoDB的特点无模式降低在OOP中使用的阻力, 适用于保存对象. 因为一个对象只需要串行化成一个JSON就可以传递给MongoDB了, 不需要进行属性映射或者类型映射. 受限集合与TTL索引受限集合在达到存储上限的时候, 旧文档会自动清除. 还可以通过tail一个受限集合, 来获取最新的数据. 如果想让数据过期, 可以通过创建TTL索引, 来显式指定一个数据的过期时间. 地理空间查询MongoDB支持2d索引, 可以方便的保存geoJSON或者x和y坐标到文档, 通过$near或者$within操作来进行附近或者区域数据. 事务MongoDB不支持事务(TODO 待补充) 如何理解MongoDB集群的高可用性详见:MongoDB高可用性 MongoDB和mysql的优劣势对比 MySQL适合于传统的对关联要求高的方面, 而对于MongoDB来说, 关联一般做成内联的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[(未完成)MongoDB聚合操作]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-aggregate%2F</url>
      <content type="text"><![CDATA[前面都是查询操作, 本文设计的是MongoDB的数据分析与利用. 内容主要包括: 聚合框架; MapReduce; 简单的聚合命令: count, distinct和group. 管道操作符\$match\$match用于对文档集合进行筛选, 通常放置在管道的靠前的位置 例如: 下面指定了只有state字段为OR的文档符合条件: 1&#123;"$match": &#123;"state": "OR"&#125;&#125; \$project投射操作, 用于提取文档中的指定字段, 例如: 1&gt; db.articles.aggregate(&#123;"$project": &#123;"author": 1&#125;&#125;) 需要的字段需要显式指定为1. 也可以在投影的同时重命名字段: 1&gt; db.articles.aggregate(&#123;"$project": &#123;"author": "$_id", "_id": 0&#125;&#125;) 上述操作将_id字段赋值给了author字段, 然后去除了_id字段, 相当于最后author代替了_id字段. 管道的使用原则将$project, $group或者$unwind操作安排在管道的开始阶段. MapReduce]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基础知识]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-basic%2F</url>
      <content type="text"><![CDATA[文档文档就是键值对的一个有序集, 相当于传统关系型数据库的一行. 比如map, hash或者dict(在JavaScript里表示为对象). 其中键是字符串类型的, 值可以是任意类型的. 文档中的键值对是有序的. 集合集合就是一组文档, 相当于一张表. 虽然集合里面可以放置任何类型的文档, 但是还是建议分开存储(后面解释). 集合可以拥有子集合, 使用”.”来界定命名空间. 例如: 一个拥有博客功能的应用可能包含两个集合, 分别是blog.posts和blog.authors. 很多mongodb工具都使用了子集合, 因为使用它来组织数据非常高效(后面介绍), 值得推荐. 数据库多个集合组成数据库. 将数据库的名字添加到集合的名字前, 可以得到集合的全限定名. 例如cms.blog.post表示cms数据库中的blog.posts集合. MongoDB启动与监控首先创建默认的数据存储目录 1$ mkdir -p /data/db 通过以下命令启动(需要保证mongodb在环境变量中) 1$ mongod 当服务器运行后, 会监听在27017端口. 同时还会启动一个基本的http服务器, 可以通过http://localhost:28017来访问数据库的管理信息. MongoDB shell首先要保证MongoDB实例已启动, 然后通过以下命令进行连接 1$ mongo MongoDB shell是一个完整的JavaScript解释器, 也就是可以运行任意的JavaScript指令. 它也是一个独立的MongoDB客户端, 在启动时会连到test数据库, 并且将数据库的连接赋值为全局变量db, 可以通过db来访问MongoDB中的数据库. 如果需要切换数据库, 只需要运行如下指令: 12&gt; use foobarswitched to db foobar 连接远程数据库1$ mongo &lt;host-ip/host-name&gt;:&lt;port&gt;/&lt;dbname&gt; 不连接数据库进行启动1$ mongo --nodb 如果后面需要重新连接到数据库的话, 使用如下指令: 12&gt; conn = new Mongo("some-host:port")&gt; db = conn.getDB("dbname")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引-初级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index%2F</url>
      <content type="text"><![CDATA[为什么要使用索引下面以一个例子来说明: 假设我们现在有一个100w条的文档数据, 每个文档数据都包含一个username字段, 其值从user1到user1000000, 假定我们希望通过username进行查询. 1&gt; db.user.find(&#123;username: "user101"&#125;) 我们可以在查询的同时开启操作的监控: 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 1000000, "nscannedObjects": 1000000, "millis": 721, ...&#125; 我们可以看到集合中的所有的文档都会被扫描, 因为无法确定集合中的username字段是唯一的. 如果不使用索引的话, 我们可以通过限制查询结果数量来强制mongo找到符合条件的结果即返回. 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 102, "nscannedObjects": 102, "millis": 2, ...&#125; 虽然上面的查询扫描数量减少了, 但是如果要查找的是user999999就还是需要整体扫描一遍. 创建索引如下是按照username字段正序(指定为1)创建索引. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;) 由于创建索引比较费时, 可以通过在另一个shell中执行db.currentOp()或者是检查mongod的日志来 查看索引创建进度. 当索引创建完成后, 再次执行最初的查询. 12345678&gt; db.user.find(&#123;"username": "user101"&#125;).explain()&#123; ... "nscanned": 1, "nscannedObjects": 1, "millis": 3, ...&#125; 使用了索引之后查询几乎可以瞬间完成, 但是每次写操作(包括插入, 更新和删除)将会耗费更多时间. 因为要同时更新文档和索引. 所以实际使用中, 不应该拥有两个以上的索引. 复合索引就是在多个字段上创建一个索引, 注意索引间是有顺序的, 例如: 1&gt; db.user.ensureIndex(&#123;"age": 1, "username": 1&#125;) 实际创建的索引会先按照age字段排序, 然后按照username字段排序. 这个索引主要有以下三种使用方法: 点查询1&gt; db.user.find(&#123;"age": 21&#125;).sort(&#123;"username": -1&#125;) 由于之前我们创建了符合索引, 所以首先可以直接定位到age为21的记录, 然后由于这些记录是按照username正序排列好的, 所以可以直接用sort()方法指定逆序输出, 不需要额外的时间开销. 多值查询1&gt; db.user.find(&#123;"age": &#123;"$gte": 21, $"lte": 30&#125;&#125;).sort(&#123;"username": 1&#125;) 由于这个查询跨了多个age值, 虽然在每个age值内username是有序的, 但是整体来看是无序的, 所以需要在内存中先对结果进行排序, 然后才能返回. 所以说这个查询通常会较为低效. 隐式索引我们现在创建了一个{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引, 实际上我们同时也获得了一个{&quot;age&quot;: 1}索引, 也就是说: 如果我们有一个N个键的索引, 那么想到哪关于我们同时获得了这N个键的前缀组成的索引. 复合索引创建的准则 用于精确匹配的字段, 放在索引的前面;用于范围匹配的字段放在最后. 假设现在要使用{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引进行查询, 构造以下查询: 1&gt; db.user.find(&#123;"age": 47, "username": &#123;"$gt": "user5", "$lt": "user8"&#125;&#125;).explain() 在基数比较高的键上建立索引, 至少要把基数高的键放在复合索引的前面 因为一个字段的基数(也就是取值的可能值)越高, 这个键上的索引就越有用. 举个例子, 比如我们在gender字段上创建索引, 那么只能将搜索空间缩小到50%左右; 而如果我们在name字段上创建索引, 那么结果集就会非常小, 查询时间大大缩短. 何时不应该使用索引通常来说, 当查询返回较小的结果集时, 索引会非常高效. 结果集在原集合中所占比例越大, 索引的速度就越慢. 因为索引需要进行两次查找, 一次是查找索引条目, 一次是根据索引去查找文档. 一般来说, 当结果集占原集合30%左右时, 就需要考虑是否直接进行全表扫描来代替索引. 索引类型唯一索引可以在单个字段上或者符合字段上创建唯一索引, 被唯一索引标识的字段在集合中不能重复. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;, &#123;"unique": true&#125;) 稀疏索引唯一索引会对该字段上所有的取值进行索引, 也就是说null也会被视为有值, 所以并不适合于在有缺失值的字段上使用, 而稀疏索引会忽略掉缺失值, 只对该字段存在值的部分文档进行索引. 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"sparse": true&#125;) 当然, 可以与唯一索引结合使用 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"unique": true, "sparse": true&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引--高级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index2%2F</url>
      <content type="text"><![CDATA[固定集合MongoDB中默认的集合是动态创建的, 可以自动增长以容纳更多的数据, 而固定集合类似于循环队列, 当集合满时会自动将最老的文档删除. 固定集合的数据被写入磁盘上的固定空间, 所以写入速度非常快. 固定集合的创建下述指令创建一个10w字节的固定集合 1&gt; db.createCollection("collection_name", &#123;"capped": true, "size": 100000&#125;) TTL索引对于固定集合来讲, 如果需要超时自动移除文档, 那么可以使用TTL索引 1&gt; db.foo.ensureIndex(&#123;"lastUpdated": 1&#125;, &#123;"expireAfterSecs": 60*60*24&#125;) 以上代码设置了超时时间为1天. 地理空间索引MongoDB支持几种类型的地理空间索引. 其中最常用的是2dsphere索引(用于地球表面类型的地图)和2d索引(用于平面地图和时间连续的数据). 2d索引对于非球面的地图(游戏地图, 时间连续的数据等), 可以使用2d索引代替2dsphere. 一个符合2d索引的文档 1234&#123; "name": "Water Temple", "title": [32, 22]&#125; 查询[20, 21]点附近的对象 1&gt; db.hyrule.find(&#123;"title": &#123;"$near": [20, 21]&#125;&#125;) 以[12,25]为圆心, 5为半径, 查询出某个圆形范围内的点 1&gt; db.hyrule.find(&#123;"title": &#123;"$within": &#123;"$center": [[12, 25], 5]&#125;&#125;&#125;) 使用GridFS存储文件GridFS是MongoDB的一种存储机制, 通常用来存储不经常改变但是经常需要连续访问的大型二进制文件.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[test]]></title>
      <url>%2F2016%2F12%2F06%2Ftest%2F</url>
      <content type="text"><![CDATA[testtest这里是更多]]></content>
    </entry>

    
  
  
</search>
