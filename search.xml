<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[从零构建部署Node.js+Express+Bootstrap Web应用]]></title>
      <url>%2F2016%2F12%2F09%2Ffull-stack-1%2F</url>
      <content type="text"><![CDATA[本文将包括以下内容: 创建一个Express应用 使用npm和package.json管理应用依赖 调整Express工程结构到MVC架构 Route和Controller概念分离 创建新的Node模块(module) 使用Git在线部署Express应用到Heroku 在进行一切操作之前, 需要先安装好Node.js, 对于*nix用户来说, 直接下载解压, 并添加到环境变量中即可完成安装. 首先从Express着手, Express是构建在Node之上的web应用框架. 使用package.json定义依赖每个Node应用的根目录都有一个文件叫做package.json, 用来记录Node应用的依赖, 例如: 1234567&#123; ... "depencencies": &#123; "express": "~4.9.0" ... &#125;&#125; 其中”~”表示使用最近的patch版本, 推荐使用. 使用npm安装Node依赖工程范围的依赖在和package.json相同的目录层级运行以下指令即可: 1$ npm install 这会将所有的依赖(包括间接依赖)下载到node_modules文件夹内. 如果后期你想向工程中追加依赖, 只需要运行以下指令: 1$ npm install &lt;package-name&gt; --save 以上指令完成了两步操作: 将指定package下载到node_modules文件夹; 将依赖条目追加到package.json文件内. 全局范围的依赖一些通用的依赖需要安装成全局依赖, 例如express generator: 1$ npm install -g express-generator 依赖会被安装到以下路径: ${NODE_HOME}/lib/node_modules/express-generator 创建并启动一个Express工程 新建一个文件夹 在文件夹内运行express npm install按照package.json的定义安装所有依赖 npm start启动程序, 浏览器访问localhost:3000即可. Express的用户请求处理逻辑如下图所示 重启一个Node应用 如果你修改了服务端的Node代码, 那么需要停止应用运行, 编译并重新启动 重启应用的方法有两种, 一种是从启动应用的控制台ctrl+c, 然后npm start, 另一种方法是使用nodemon, nodemom是Node应用的监控程序, 能够简化Node应用的开发. 安装方法如下: 1$ npm install -g nodemon 然后使用nodemon指令代替npm start启动应用程序. 如果你只是修改了Jade模板, CSS文件, 或者客户端的js代码, 无需重新启动应用 调整Express工程结构到MVC模式首先在根目录下新创建一个app_server文件夹, 将根目录下的routes和views文件夹移到里面: 然后更改app.js文件, 将两者重新定位到新的位置. 具体的来说就是将原来的 123app.set('views', path.join(__dirname, 'views'));var index = require('./routes/index');var users = require('./routes/users'); 变更为 123app.set('views', path.join(__dirname, 'app_server', 'views'));var index = require('./app_server/routes/index');var users = require('./app_server/routes/users'); Node模块(module)的生成与使用举个例子, 现在我们有a.js和b.js两个文件, 假设现在它们在同级目录下, 我们想在b.js文件中调用a.js中定义的变量或函数. 下面是a.js文件的内容 123module.exports.logThis = function(message) &#123; console.log(message);&#125; 上述代码将logThis变量(函数)暴露出来, 供其他模块使用, 经过这样设定后我们就可以在b.js中如下调用 12var myModule = require("./a")myModule.logThis("It works!") 需要注意的一点是, require()方法并不需要加后缀, 它会自动依以下顺序搜索: 寻找同名js文件 寻找同名文件夹下的index.js文件 Bootstrap安装 首先下载Bootstrap发行版, 解压并添加到Express工程下的public目录(public目录是用于存放静态资源的目录)下的bootstrap目录(需新建). 由于Bootstrap依赖jquery, 所以我们还要下载jquery, 从这里下载, 注意下载完整版的, 不要下载slim版的, 点击之后, 会跳出一个代码页面, 直接拷贝全部, 然后保存在public/javascript/jquery-&lt;具体的版本.min.js文件中即可. 清空Express默认的样式. 具体的来讲, 就是清空public/stylesheet/style.css文件中的内容 安装Bootstrap主题这里以Amelia主题为例, 从这里下载, 将解压得到的amelia.bootstrap.css和amelia.bootstrap.min.css拷贝到Express工程下的public/bootstrap/css文件夹下. Jade模板的使用Jade模板的使用原则是: 设计一系列的模板布局, 然后让其他文件去扩展 这里我们来看一个例子, 下面分别是layout.jade和index.jade文件的内容: 1234extend layoutblock content h1= title p Welcome to #&#123;title&#125; 上面代码的意思是index.jade扩展了layout.jade, block content是layout.jade中声明的一个html填充块, 这里向里面填充了一个&lt;h1&gt;和一个&lt;p&gt;. 下面让我们来看一下layout.jade. 123456789doctype htmlhtml head title= title link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/style.css&apos;) body block content script(src=&apos;/javascript/jquery-3.1.1.min.js&apos;) script(src=&apos;/bootstrap/js/bootstrap.min.js&apos;) layout.jade除了用于定义html的模板, 还用来进行css和js脚本的连接, 注意: js脚本放在页面最下面有利于提升网页的加载速度. 此外, 第一行设置的viewport有利于页面能够在移动设备上良好的缩放. 到此, 使用Bootstrap的Amelia主题之后的显示效果如下: 使用Heroku进行网站的对外在线演示将网站托管到在线平台上的意义是: 可以便利的进行跨浏览器的测试, 跨设备测试, 并且能够向同事和合作伙伴快速展示与交流开发阶段性进展. 类似的平台服务还有Google Cloud Platform, Nodejitsu, OpenShift等. 安装Heroku 从这里注册一个免费账号 下载Heroku toolbelt, 或者直接使用以下指令在Ubuntu中下载 1$ wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh 触发安装 1$ heroku --version 验证安装成果 1234$ heroku --versionheroku-toolbelt/3.43.15 (x86_64-linux) ruby/1.9.3heroku-cli/5.5.6-a9ddee4 (linux-amd64) go1.7.4You have no installed plugins. 登陆(实际上完成了类似ssh密钥对生成并上传公钥的工作) 1$ heroku login 使用Heroku提交Node.js应用 首先需要保证云端的运行环境与本地开发环境一致 具体的是在package.json中添加一个engines配置块, 指明node和npm的版本, 如果不清楚的话, 还是确认一下比较好: 12$ node --version$ npm --version 下面是示例的package.json文件: 123456789&#123; "name": "Loc8r" ... "engines": &#123; "node": "~4.6.0", "npm": "~2.15.9" &#125;, ...&#125; 创建一个云端启动脚本 具体来说就是创建一个启动脚本, 指明我们应用的类型以及启动指令, 对于Node.js应用来说, 需要在应用的根目录下创建一个名为Procfile的文件, 示例内容如下: 1web: npm start 使用heroku local进行本地验证 heroku local的前身是foreman, 但是现在的heroku toolbelt中已经用前者替换掉了了后者, 详见如下官方通知 heroku local工具是用来在提交应用前进行本地验证的, 使用heroku local启动应用前需要先关闭本地应用, 然后使用以下指令启动: 1$ heroku local web 程序成功启动后会监听在5000端口, 我们可以通过localhost:5000来访问, 显示效果应与之前本地直接运行相同. 将应用托管到Heroku 首先需要初始化一个git仓库, 添加.gitignore文件, 推荐使用这里自动生成(键入Node即可). 然后在云端创建一个heroku应用容器(隐式完成了本地仓库的关联) 123$ heroku createCreating app... done, ⬢ sheltered-everglades-85543https://sheltered-everglades-85543.herokuapp.com/ | https://git.heroku.com/sheltered-everglades-85543.git 推送到远程仓库 1$ git push heroku master 在heroku云端用测试机(dyno)来运行部署的程序 每位用户都会免费获得一个可用的web测试机, 使用如下指令来开启它 12$ heroku ps:scale web=1Scaling dynos... done, now running web at 1:Free 在线浏览部署情况 1$ heroku open 自动在云端的网址上看到部署的应用的情况 之后修改了应用代码后, 只需要push到heroku容器的master分支, 就会自动更新并部署.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基础知识]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-basic%2F</url>
      <content type="text"><![CDATA[文档文档就是键值对的一个有序集, 相当于传统关系型数据库的一行. 比如map, hash或者dict(在JavaScript里表示为对象). 其中键是字符串类型的, 值可以是任意类型的. 文档中的键值对是有序的. 集合集合就是一组文档, 相当于一张表. 虽然集合里面可以放置任何类型的文档, 但是还是建议分开存储(后面解释). 集合可以拥有子集合, 使用”.”来界定命名空间. 例如: 一个拥有博客功能的应用可能包含两个集合, 分别是blog.posts和blog.authors. 很多mongodb工具都使用了子集合, 因为使用它来组织数据非常高效(后面介绍), 值得推荐. 数据库多个集合组成数据库. 将数据库的名字添加到集合的名字前, 可以得到集合的全限定名. 例如cms.blog.post表示cms数据库中的blog.posts集合. MongoDB启动与监控首先创建默认的数据存储目录 1$ mkdir -p /data/db 通过以下命令启动(需要保证mongodb在环境变量中) 1$ mongod 当服务器运行后, 会监听在27017端口. 同时还会启动一个基本的http服务器, 可以通过http://localhost:28017来访问数据库的管理信息. MongoDB shell首先要保证MongoDB实例已启动, 然后通过以下命令进行连接 1$ mongo MongoDB shell是一个完整的JavaScript解释器, 也就是可以运行任意的JavaScript指令. 它也是一个独立的MongoDB客户端, 在启动时会连到test数据库, 并且将数据库的连接赋值为全局变量db, 可以通过db来访问MongoDB中的数据库. 如果需要切换数据库, 只需要运行如下指令: 12&gt; use foobarswitched to db foobar 连接远程数据库1$ mongo &lt;host-ip/host-name&gt;:&lt;port&gt;/&lt;dbname&gt; 不连接数据库进行启动1$ mongo --nodb 如果后面需要重新连接到数据库的话, 使用如下指令: 12&gt; conn = new Mongo("some-host:port")&gt; db = conn.getDB("dbname")]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引-初级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index%2F</url>
      <content type="text"><![CDATA[为什么要使用索引下面以一个例子来说明: 假设我们现在有一个100w条的文档数据, 每个文档数据都包含一个username字段, 其值从user1到user1000000, 假定我们希望通过username进行查询. 1&gt; db.user.find(&#123;username: "user101"&#125;) 我们可以在查询的同时开启操作的监控: 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 1000000, "nscannedObjects": 1000000, "millis": 721, ...&#125; 我们可以看到集合中的所有的文档都会被扫描, 因为无法确定集合中的username字段是唯一的. 如果不使用索引的话, 我们可以通过限制查询结果数量来强制mongo找到符合条件的结果即返回. 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 102, "nscannedObjects": 102, "millis": 2, ...&#125; 虽然上面的查询扫描数量减少了, 但是如果要查找的是user999999就还是需要整体扫描一遍. 创建索引如下是按照username字段正序(指定为1)创建索引. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;) 由于创建索引比较费时, 可以通过在另一个shell中执行db.currentOp()或者是检查mongod的日志来 查看索引创建进度. 当索引创建完成后, 再次执行最初的查询. 12345678&gt; db.user.find(&#123;"username": "user101"&#125;).explain()&#123; ... "nscanned": 1, "nscannedObjects": 1, "millis": 3, ...&#125; 使用了索引之后查询几乎可以瞬间完成, 但是每次写操作(包括插入, 更新和删除)将会耗费更多时间. 因为要同时更新文档和索引. 所以实际使用中, 不应该拥有两个以上的索引. 复合索引就是在多个字段上创建一个索引, 注意索引间是有顺序的, 例如: 1&gt; db.user.ensureIndex(&#123;"age": 1, "username": 1&#125;) 实际创建的索引会先按照age字段排序, 然后按照username字段排序. 这个索引主要有以下三种使用方法: 点查询1&gt; db.user.find(&#123;"age": 21&#125;).sort(&#123;"username": -1&#125;) 由于之前我们创建了符合索引, 所以首先可以直接定位到age为21的记录, 然后由于这些记录是按照username正序排列好的, 所以可以直接用sort()方法指定逆序输出, 不需要额外的时间开销. 多值查询1&gt; db.user.find(&#123;"age": &#123;"$gte": 21, $"lte": 30&#125;&#125;).sort(&#123;"username": 1&#125;) 由于这个查询跨了多个age值, 虽然在每个age值内username是有序的, 但是整体来看是无序的, 所以需要在内存中先对结果进行排序, 然后才能返回. 所以说这个查询通常会较为低效. 隐式索引我们现在创建了一个{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引, 实际上我们同时也获得了一个{&quot;age&quot;: 1}索引, 也就是说: 如果我们有一个N个键的索引, 那么想到哪关于我们同时获得了这N个键的前缀组成的索引. 复合索引创建的准则 用于精确匹配的字段, 放在索引的前面;用于范围匹配的字段放在最后. 假设现在要使用{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引进行查询, 构造以下查询: 1&gt; db.user.find(&#123;"age": 47, "username": &#123;"$gt": "user5", "$lt": "user8"&#125;&#125;).explain() 在基数比较高的键上建立索引, 至少要把基数高的键放在复合索引的前面 因为一个字段的基数(也就是取值的可能值)越高, 这个键上的索引就越有用. 举个例子, 比如我们在gender字段上创建索引, 那么只能将搜索空间缩小到50%左右; 而如果我们在name字段上创建索引, 那么结果集就会非常小, 查询时间大大缩短. 何时不应该使用索引通常来说, 当查询返回较小的结果集时, 索引会非常高效. 结果集在原集合中所占比例越大, 索引的速度就越慢. 因为索引需要进行两次查找, 一次是查找索引条目, 一次是根据索引去查找文档. 一般来说, 当结果集占原集合30%左右时, 就需要考虑是否直接进行全表扫描来代替索引. 索引类型唯一索引可以在单个字段上或者符合字段上创建唯一索引, 被唯一索引标识的字段在集合中不能重复. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;, &#123;"unique": true&#125;) 稀疏索引唯一索引会对该字段上所有的取值进行索引, 也就是说null也会被视为有值, 所以并不适合于在有缺失值的字段上使用, 而稀疏索引会忽略掉缺失值, 只对该字段存在值的部分文档进行索引. 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"sparse": true&#125;) 当然, 可以与唯一索引结合使用 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"unique": true, "sparse": true&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引--高级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index2%2F</url>
      <content type="text"><![CDATA[固定集合MongoDB中默认的集合是动态创建的, 可以自动增长以容纳更多的数据, 而固定集合类似于循环队列, 当集合满时会自动将最老的文档删除. 固定集合的数据被写入磁盘上的固定空间, 所以写入速度非常快. 固定集合的创建下述指令创建一个10w字节的固定集合 1&gt; db.createCollection("collection_name", &#123;"capped": true, "size": 100000&#125;) TTL索引对于固定集合来讲, 如果需要超时自动移除文档, 那么可以使用TTL索引 1&gt; db.foo.ensureIndex(&#123;"lastUpdated": 1&#125;, &#123;"expireAfterSecs": 60*60*24&#125;) 以上代码设置了超时时间为1天. 地理空间索引MongoDB支持几种类型的地理空间索引. 其中最常用的是2dsphere索引(用于地球表面类型的地图)和2d索引(用于平面地图和时间连续的数据). 2d索引对于非球面的地图(游戏地图, 时间连续的数据等), 可以使用2d索引代替2dsphere. 一个符合2d索引的文档 1234&#123; "name": "Water Temple", "title": [32, 22]&#125; 查询[20, 21]点附近的对象 1&gt; db.hyrule.find(&#123;"title": &#123;"$near": [20, 21]&#125;&#125;) 以[12,25]为圆心, 5为半径, 查询出某个圆形范围内的点 1&gt; db.hyrule.find(&#123;"title": &#123;"$within": &#123;"$center": [[12, 25], 5]&#125;&#125;&#125;) 使用GridFS存储文件GridFS是MongoDB的一种存储机制, 通常用来存储不经常改变但是经常需要连续访问的大型二进制文件.]]></content>
    </entry>

    
  
  
</search>
