<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java-通过lambda表达式进行惰性计算]]></title>
      <url>%2F2017%2F02%2F26%2Fjava-lambda0%2F</url>
      <content type="text"><![CDATA[lambda表达式的出现使得JDK8内部发生了很多有趣的变化, 其中就包括惰性计算的特性. 这里以JDK标准库中的Logger为例, 1.8以前的log方法有如下签名: 1234567public void log(Level level, String msg) &#123; if (!isLoggable(level)) &#123; return; &#125; LogRecord lr = new LogRecord(level, msg); doLog(lr); &#125; 也就是说客户端程序调用log方法的时候, 无论最终是否触发log行为, msg始终是要被计算的. 若计算msg是非常耗时的行为, 那么无疑会造成不必要的开销. 下面是一个调用的例子: 1log(Level.WARNING, "Log msg: " + someExpensiveOperation()); 在java 1.8版本出现之后, 该方法多了如下重载: 1234567public void log(Level level, Supplier&lt;String&gt; msgSupplier) &#123; if (!isLoggable(level)) &#123; return; &#125; LogRecord lr = new LogRecord(level, msgSupplier.get()); doLog(lr); &#125; Supplier是一个FunctionalInterface, 也就是说现在的log方法可以接受一个无参的lambda表达式作为参数, 而计算的过程也被延迟到了supplier.get()的调用时. 改进后的调用例子: 12// 注意: 传入的lambda表达式并不会立即执行, 而是在log中判断isLoggable(level)成功后才会执行log(Level.WARNING, () -&gt; "Log msg: " + someExpensiveOperation());]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用REST API操作MongoDB(一)]]></title>
      <url>%2F2017%2F02%2F26%2Ffull-stack5%2F</url>
      <content type="text"><![CDATA[使用REST API, 我们能够通过HTTP请求来对MongoDB进行CRUD操作. REST API对于我们的应用来说就是一个无状态的接口, 对于MEAN技术栈来讲, REST API的地位是创建一个暴露一个操作数据库的无状态接口, 供其他应用操作数据库的数据. 设计REST API的请求处理部分REST API功能通常, 我们希望借助REST API完成以下操作 创建一个新记录 读取一个list的记录 读取指定的记录 更新指定记录 删除指定记录 假如我们现在要创建的是地址记录, 假定我们要使用的URL路径是/locations, 那么各个操作对应到URL路径之后如下表所示 动作 URL路径 路径参数 例子 创建一个新记录 /locations http://example/api/locations 读取一个list的记录 /locations http://example/api/locations 读取指定的记录 /locations locationId http://example/api/locations/123 更新指定记录 /locations locationId http://example/api/locations/123 删除指定记录 /locations locationId http://example/api/locations/123 通过上表可以看出, 多个不同的动作可能对应的是相同的URL路径, 那么如何进行动作的区分呢? 答案是通过HTTP请求类型来判断. HTTP请求类型通常, REST API使用到四种HTTP请求, 它们的用途和相应如下所示 HTTP请求类型 用途 响应 POST 创建新记录 数据库中插入新记录 GET 读取记录 从数据库返回指定记录 PUT 更新记录 更新数据库中的指定记录 DELETE 删除记录 数据库中指定记录被删除 结合HTTP请求类型和URL路径确定唯一的操作 动作 HTTP请求类型 URL路径 路径参数 例子 创建一个新记录 POST /locations http://example/api/locations 读取一个list的记录 GET /locations http://example/api/locations 读取指定的记录 GET /locations locationId http://example/api/locations/123 更新指定记录 PUT /locations locationId http://example/api/locations/123 删除指定记录 DELETE /locations locationId http://example/api/locations/123 使用REST API操作子文档以上介绍都是REST API操作父文档, 如果想操作子文档, 首先需要获取到父文档, 也就是如上表中的http://example/api/locations/123这样的路径, 现在假定每个location文档中还内嵌了名为reviews的子文档, 那么它所对应的操作如下 动作 HTTP请求类型 URL路径 路径参数 例子 创建一个新记录 POST /locations/locationId/reviews locationId http://example/api/locations/123/reviews 读取指定的记录 GET /locations/locationId/reviews locationIdreviewId http://example/api/locations/123/reviews/abc 更新指定记录 PUT /locations/locationId/reviews locationIdreviewId http://example/api/locations/123/reviews/abc 删除指定记录 DELETE /locations/locationId/reviews locationIdreviewId http://example/api/locations/123/reviews/abc 注意, 子文档的操作并没有一个读取list的操作, 因为这个操作可以通过对父文档操作进行实现. 设计REST API响应(Response)和状态码REST API的另一部分就是响应的设计, 响应一般来说包含两个部分: 返回数据 HTTP状态码 对于返回数据, 通常是JSON或者XML类型的, 这里我们选择JSON类型, 因为它比XML数据更加紧凑, 并且天然适应MEAN技术栈. 对于每个请求, 返回数据都应该有三种类型: 包含正确返回的被请求数据的JSON对象 包含错误信息的JSON对象 null响应 常用的HTTP状态码 HTTP状态码通常是用来和响应一同返回的, 用于表明HTTP请求的执行情况. 常用的HTTP状态码共有10种 状态码 名称 适用场景 200 OK GET或者PUT请求成功 201 Created POST请求成功 204 No content DELETE请求成功 400 Bad request GET, PUT或者POST请求由于内容不符合标准而失败 401 Unauthorized 身份验证未通过 403 Forbidden 不允许的请求 404 Not found 请求的URL没有资源或者参数错误 405 Method not allowed 指定的URL不允许此种请求类型 409 Conflict POST失败, 试图插入重复数据 500 Internal server error 服务器或数据库故障 在Express中建立响应API使REST API不与应用的其他处理逻辑混杂, 所以这里我们单独对其进行管理. 首先, 在应用的根目录新建一个app_api目录, 这个目录将会包含routes, controllers, models(注意并没有views) 创建REST API路由 首先创建根路由, 也就是index.js, 并将其加载到app.js中, 1234567var index = require('./app_server/routes/index');// 以下是新增的路由var apiIndex = require('./app_api/routes/index');app.use('/', index);// 以下是新增的路由app.use('/api', apiIndex); TODO 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular基础(二)--第一个Angular程序]]></title>
      <url>%2F2017%2F02%2F26%2Fangular2%2F</url>
      <content type="text"><![CDATA[添加Angular到现有的web程序中的方法 步骤1: 下载Angular的lib 到官网上下载即可, 下载的文件一般叫做angular.min.js 步骤2: 创建一个Angular模块 创建一个js文件, 然后进行angular模块的创建, controller的创建等一系列操作. 例如, 我们想创建一个叫做”loc8rApp”的Angular模块. 123456789101112// 创建一个angular模块, 相当于setter方法angular.module('loc8rApp', []);// scope参数是随着controller的建立隐式创建的var myController = function ($scope) &#123; $scope.myInput = "world!";&#125;;// 相当于一个getter方法, 获取了"loc8rApp"这个模块.angular.module('loc8rApp') // 这里相当于一个setter方法, 设置了一个controller .controller('myController', myController); 步骤3: 关联Angular模块到html文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html ng-app="loc8rApp"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Angular binding test&lt;/title&gt; &lt;script src="angular.min.js"&gt;&lt;/script&gt; &lt;!--这里一定要记得引入一个模块--&gt; &lt;script src="loc8rApp.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller="myController"&gt; &lt;input ng-model="myInput" /&gt; &lt;h1&gt;Hello &#123;&#123;myInput&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 经过以上配置, 一个简单的Angular程序就完成了, 我们可以通过在浏览器中打开网页查看效果: 随着我们的输入, 视图也会随之改变. 使用ng-repeat遍历数组元素我们可以如下定义一个控制器: 123var myController = function ($scope) &#123; $scope.items = ['one', 'two', 'three'];&#125;; 然后在html中这样遍历(注意, ng-repeat要绑定在需要重复的元素上, 在下例中是li元素) 12345&lt;body ng-controller="myController"&gt; &lt;ul&gt; &lt;li ng-repeat="item in items"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 在浏览器中查看是如下效果: Angular filter]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular基础(一)]]></title>
      <url>%2F2017%2F02%2F26%2Fangular1%2F</url>
      <content type="text"><![CDATA[Angular是客户端的框架, 让我们能够在浏览器中构建整个应用程序.我们能够使用Angular来与REST API进行交互. Angular是一个MVW模式的框架, W的意思是”Whatever works for you”. 意思就是它能够作为controller, view-model, services的任意一种使用. 双向数据绑定(two-way data binding)双向数据绑定指的是model和view的绑定, 它有以下特征 视图的改变会更新模型, 模型的改变也会更新视图, 一切都是发生在浏览器中的 Angular ScopeAngular有一个rootScope, 也就是ng-app定义的scope, 子scope是由ng-controller创建的. 在Angular中, scope是与view, model和controller绑定的, 它们使用的是相同的scope.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Oracle到MySQL数据库迁移之--主键生成策略替换]]></title>
      <url>%2F2017%2F01%2F03%2Fdb-migrate1%2F</url>
      <content type="text"><![CDATA[Oracle数据库到MySQL数据库迁移过程中的一大难题就是主键生成策略的替换. 如果之前的程序中使用Oracle的Sequence机制来实现主键的自增的话. MySQL中需要使用TableGenerator进行等价替换. 替换的时候, 主要有三个地方需要修改: 以注解方式完成hibernate映射的实体; 以xml方式完成hibernate映射的实体; 数据库存储过程; 注解方式完成hibernate映射的实体的修改使用Oracle Sequence假如你之前的程序使用的是Sequence, 这里以一个名为SEQ的Sequence为例, 那么你操作id字段的代码应该长的是下面这个样子: 1234567// 注意: 如果不指定sequenceName的话, 默认为HIBERNATE_SEQUENCE, 这个序列也需要在Oracle中手动建立.@SequenceGenerator(name = "generator", sequenceName = "SEQ")@Id@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "generator")public Long getId() &#123; return id;&#125; 使用MySQL表模拟Oracle Sequence首先你需要在MySQL中建立一个表sys_sequence, 表中有两个字段, 一个是seq_name, 代表Oracle序列的名称, 另一个是current_value, 代表该序列的当前值(注意: 需要将此初始值设定为Oracle数据库中对应序列的当前值.). 表的样子如下: 123456&gt; select * from sys_sequence;+--------------+------------+| seq_name | curr_value |+--------------+------------+| SEQ | 2809 |+--------------+------------+ . 然后在程序中如下编写: 1234567/*** allocationSize是每次程序启动第一次插入时与之前最大值的差值.*/@Id@TableGenerator(name = "sequence", table = "sys_sequence", pkColumnName = "seq_name", valueColumnName = "curr_value", pkColumnValue = "SEQ", allocationSize = 1)@GeneratedValue(strategy = GenerationType.TABLE, generator = "sequence")private Long id; xml方式完成hibernate映射的实体的修改使用Oracle Sequence之前使用Sequence作为主键生成策略的时候, xml映射文件片段如下: 12345&lt;id name="id"&gt; &lt;generator class="sequence"&gt; &lt;param name="sequence"&gt;SEQ&lt;/param&gt; &lt;/generator&gt;&lt;/id&gt; 使用MySQL表模拟Oracle Sequence表的结构与前面注解方式所用的表结构相同. 这次我们在xml中使用的generator是org.hibernate.id.enhanced.TableGenerator: 123456789&lt;id name="id"&gt; &lt;generator class="org.hibernate.id.enhanced.TableGenerator"&gt; &lt;param name="table_name"&gt;sys_sequence&lt;/param&gt; &lt;param name="segment_column_name"&gt;seq_name&lt;/param&gt; &lt;param name="value_column_name"&gt;curr_value&lt;/param&gt; &lt;param name="segment_value"&gt;SEQ&lt;/param&gt; &lt;param name="increment_size"&gt;1&lt;/param&gt; &lt;/generator&gt;&lt;/id&gt; 存储过程的修改存储过程中, 主要涉及到Sequence的nextval()等方法的替换, 我们同样可以在MySQL中进行模拟. 使用Oracle Sequence假设我们现在有一个Sequence名为SEQ, 那么我们通常在存储过程中使用如下函数获得SEQ的下一个值: 1SEQ.nextval 使用MySQL模拟Oracle Sequence首先需要创建一个表格, 用于存储所有序列的名称, 当前值以及递增步长. 这里我们继续沿用前面所述的sys_sequence表, 不过还需要为表新增一个字段increment_by, 我们对照Oracle数据库的设置手动进行increment_by初值的设定. 123456&gt; select * from sys_sequence;+--------------+------------+--------------+| seq_name | curr_value | increment_by |+--------------+------------+--------------+| SEQ | 2809 | 1 |+--------------+------------+--------------+ 然后在数据库中新增两个函数, 一个是currval, 用于获取模拟的Sequence的当前值: 1234567CREATE DEFINER=`root`@`%` FUNCTION `currval`(`v_seq_name` varchar(50)) RETURNS decimal(18,0)BEGINDECLARE v_currval DECIMAL(18); SET v_currval = 1; SELECT curr_value INTO v_currval FROM sys_sequence WHERE seq_name = v_seq_name; RETURN v_currval; END 另一个是nextval, 用户获取模拟的Sequence的下一个值: 12345CREATE DEFINER=`root`@`%` FUNCTION `nextval`(`v_seq_name` varchar(50)) RETURNS decimal(18,0)BEGIN UPDATE sys_sequence SET curr_value = curr_value + increment_by WHERE seq_name = v_seq_name; RETURN currval(v_seq_name); END 之后在需要使用Sequence的地方, 使用如下语句替代即可: 1nextval('SEQ') 小结如此一来, 就达到了利用MySQL的表来模拟Oracle的Sequence的目的. 以后每当有需要替换的序列, 都在前面建立的sys_sequence中新增一行即可.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Heroku连接云端MongoDB的方法]]></title>
      <url>%2F2016%2F12%2F11%2Ffull-stack4%2F</url>
      <content type="text"><![CDATA[之前我们已经简单的在Heroku上部署了正在开发的web应用, 现在我们的应用要使用MongoDB数据库, 如何在云端部署一个MongoDB连接呢? 再进一步, 最终我们的目的是生产和开发环境连接不同数据库. 本文将完整叙述整个流程. 注册MongoLab账号我们这里将使用MongoLab, 首先需要注册账号, 相关文档请见这里 创建一个新数据库登陆后按照如下操作 选择single node, sandbox, 注意, 只有特定的区域才有single node节点可选, 需要自己手动试一下哪个可行. 创建成功后的效果 如果没有创建成功, 多半是数据库名称冲突了, 多试几个就好. 点击Name进入数据库, 提示要创建一个用户来使用数据库, 那么我们切换到Users标签, 点击add database user 配置Mongolab数据库连接字符串到heroku的配置文件中 123$ heroku config:set MONGOLAB_URI=mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyhSetting MONGOLAB_URI and restarting ⬢ sheltered-everglades-85543... done, v10... 同步本地开发数据库的测试数据到Mongolab 创建一个临时文件夹, 用于本地开发数据库的备份 1$ mkdir -p ~/tmp/mongodump 备份本地开发数据库 1$ mongodump -h localhost:27017 -d Loc8r -o ~/tmp/mongodump 还原数据到云端数据库 1234$ mongorestore -h ds127958.mlab.com:27958 -d congyh -u &lt;username&gt; -p &lt;password&gt; ~/tmp/mongodump/Loc8r...2016-12-11T12:40:06.685+0800 finished restoring congyh.locations (3 documents)2016-12-11T12:40:06.685+0800 done 检查数据还原情况 首先使用mongo shell连接到远程数据库 123456$ mongo ds127958.mlab.com:27958/congyh -u &lt;username&gt; -p &lt;password&gt;MongoDB shell version v3.4.0connecting to: mongodb://ds127958.mlab.com:27958/congyhMongoDB server version: 3.2.11WARNING: shell and server versions do not matchrs-ds127958:PRIMARY&gt; 列出数据 12&gt; show collections&gt; db.locations.find() 让应用根据环境自动选择连接的数据库经过以上操作, 我们获得了一个和本地开发数据库同步的云端数据库, 由于我们的应用同时在本地开发和Heroku部署, 需要让应用根据环境自动连接到正确的数据库. 设置NODE_ENV环境变量 首先需要将heroku上部署的应用切换到production环境(注意: 要在应用根目录下执行指令). 123$ heroku config:set NODE_ENV=productionSetting NODE_ENV and restarting ⬢ sheltered-everglades-85543... done, v11NODE_ENV: production 更改应用源码中数据库连接的设置 12345var dbURI = 'mongodb://localhost/Loc8r';if (process.env.NODE_ENV === 'production') &#123; dbURI = process.env.MONGOLAB_URI;&#125;mongoose.connect(dbURI); 本地测试连接到本地开发数据库和Mongolab数据库 首先测试连接到本地开发数据库 12$ nodemonMongoose connected to mongodb://localhost/Loc8r 然后测试连接到Mongolab数据库 12$ NODE_ENV=production MONGOLAB_URI=mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh nodemonMongoose connected to mongodb:///&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh 测试成功后, 将应用推送到Heroku仓库部署 123$ git add .$ git commit -am "add mongolab support"$ git push heroku master 通过检查heroku云端应用日志, 验证数据库连接情况 123$ heroku logs...2016-12-11T05:08:18.152506+00:00 app[web.1]: Mongoose connected to mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh 以上, 就完成了生产和开发环境连接不同数据库的配置.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百度地图静态图API使用指南]]></title>
      <url>%2F2016%2F12%2F10%2Fbaidumap-static-api%2F</url>
      <content type="text"><![CDATA[本文的目的是根据经纬度获取一张指定大小的静态地图, 用于内嵌在网页中. 步骤1: 申请百度开发者账号 这部没什么好讲的, 和申请百度账号相仿 步骤2: 申请一个密钥 点击API控制台-&gt;开发-&gt;静态图API 点击获取密钥, 勾选全部权限, 然后设置访问网址为0.0.0.0/0. 点击API控制台, 这里可以看见先前生成的密钥 步骤3: 在应用中嵌入图片, url指定为符合静态图API的网址 这里举一个示例网址 http://api.map.baidu.com/staticimage/v2?ak=这里是你自己的ak&amp;mcode=666666&amp;center=116.403874,39.914888&amp;width=400&amp;height=350&amp;zoom=11&amp;markers=116.403874,39.914888 嵌在程序中会达到以下效果 其中 ak是刚才的密钥 center是经纬度 markers是地图标注的经纬度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongoose+Mongo+Express]]></title>
      <url>%2F2016%2F12%2F10%2Ffull-stack3%2F</url>
      <content type="text"><![CDATA[Mongoose是在Express应用与MongoDB之间, 负责两者的连接与数据交换. 使用Mongoose我们可以方便的定义数据结构. Mongoose的地位如下图所示 添加Mongoose到应用中Mongoose是一个npm模块, 可以像其他模块一样添加到程序中, 并写入依赖 1$ npm install --save mongoose 配置Mongoose到应用范围内在Express应用范围导入mongoose连接, 应在工程根目录的app.js中进行引入, 这里由于我们使用的是MVC架构, 所以应该将数据库部分的管理归类在models文件夹中. 我们在目录结构如下 123456789app.jsapp_server├── controllers├── models └──db.js├── routes└── views └── _includes index.js 我们在db.js中添加如下 1var mongoose = require('mongoose') 然后在app.js中新增如下配置 1require('./app_server/models/db') 由于我们不需要从db.js模块暴露方法, 不需要为require操作指定变量. 使用Mongoose指定连接连接格式如下 如果我们是连接到本地mongo实例, 那么username, password, port字段都是可以省略的. 继续向db.js模块添加如下语句, 完成到本地mongo实例的连接 12var dbURI = 'mongodb://localhost/Loc8r';mongoose.connect(dbURI); 注: 关于如何启动本地mongo实例, 请见我的文章:MongoDB基础知识 监控mongoose连接事件现在我们想监控连接成功, 连接失败, 连接断开三个事件, 只需要向db.js追加如下代码 123456789mongoose.connection.on('connected', function() &#123; console.log('Mongoose connected to ' + dbURI);&#125;);mongoose.connection.on('error', function(err) &#123; console.log('Mongoose connection error: ' + err);&#125;);mongoose.connection.on('disconnected', function() &#123; console.log('Mongoose disconnected');&#125;); 关闭Mongoose连接由于node应用停止时, mongo实例的连接池不会自动关闭, 下面我们将编写代码, 在Node应用退出的时候, 自动关闭mongo连接池. Node应用退出前, 根据你启动应用的方式不同, 会释放出不同的信号, 如果我们想在任何场景都使Node应用退出时自动关闭连接, 则需要捕获所有的信号类型. 为此, 我们首先要定义一个通用的关闭连接的函数, 在里面完成mongoose连接的关闭. 1234567891011121314/** * 关闭mongoose连接 * &lt;p&gt; * 这里定义了一个闭包, 外层的作用是为里层的函数提供'环境', 这里也就是msg参数. * 否则mongoose.connection.close本身是不接收带参数的回调函数的 * @param msg 触发关闭的事件类型 * @param callback 负责进行Node应用的关闭 */var gracefulShutdown = function (msg, callback) &#123; mongoose.connection.close(function () &#123; console.log('Mongoose disconnected through' + msg); callback(); &#125;);&#125;; 类型1: SIGINT 此种信号产生在使用npm start指令启动的node应用停止前, 现在我们要在应用捕获到这个信号的时候先执行mongoose的关闭逻辑. 12345process.on('SIGINT', function () &#123; gracefulShutdown('app termination', function () &#123; process.exit(0); &#125;)&#125;); 类型2: SIGTERM 此种信号产生在Heroku关闭应用进程前, 同样, 我们要在捕获到这个信号的时候先关闭mongoose连接. 12345process.on('SIGTERM', function () &#123; gracefulShutdown('Heroku app shutdown', function () &#123; process.exit(0); &#125;)&#125;); 类型3: SIGUSR2 此种信号产生是用来通知nodemon进程来重启node应用的, 由于nodemon进程本身也依赖这个信号来进行node应用的重启逻辑, 所以我们不应该完全截断, 而是应该在捕获信号, 完成关闭mongoose逻辑之后再手动发出一个同样的信号, 通知nodemon完成应用的重启. 并且仅捕获此信号一次, 防止第二次手动释放的信号又被应用进程截获. 12345678// 注意, 这里与上面的程序有两点不同, 一个是只捕获一次信号// 另一点是这里用的是kill, 要求立即结束程序, 并要重新释放同样的信号// 供nodemon使用process.once('SIGUSR2', function () &#123; gracefulShutdown('nodemon restart', function () &#123; process.kill(process.pid, 'SIGUSR2'); &#125;)&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jade模板中变量的使用]]></title>
      <url>%2F2016%2F12%2F10%2Ffull-stack2%2F</url>
      <content type="text"><![CDATA[形式1: JavaScript行内代码 1h1= pageHeader.title 形式2: 插值 1some text #&#123;pageHeader.strapline&#125; 注意: 以上两种做法都会将html代码直接转为文本输出(出于安全考虑), 如果想保留原来的html标签输出, 则使用!=和!{}的形式即可 形式3: 使用JavaScript代码段 12- for (var i = 1; i &lt; location.rating; i++) &lt;本行为Jade代码&gt; 注意: 整体上来看, 与JavaScript语法相当像, 不过现在不是用大括号标识代码块, 而是用缩进来标志. if语句不需要用”-“连接 形式4: 使用mixin定义可重用的代码段 无参数的mixin定义 12mixin welcome p Welcome 调用mixin的语法为 1+welcome 下面是带参数的mixin定义 123mixin outputRating(rating) - for (var i = 1; i &lt;= rating; i++) &lt;这里是jade代码&gt; 调用带参数的mixin语法 1+outputRating(&lt;实参&gt;) 如果我们想要在其他文件中使用在本文件中定义的mixin, 通过include关键字加路径实现. 例如, 现在我们的目录层级如下所示: 123├── _includes│ └── sharedHTMLfunctions.jade└── locations-list.jade 我们想通过location-list.jade文件来引用_includes/sharedHTMLfunctions.jade中的mixin, 可以如下使用: 123include _includes/sharedHTMLfunctions...+outputRating(&lt;实参&gt;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零构建部署Node.js+Express+Bootstrap Web应用]]></title>
      <url>%2F2016%2F12%2F09%2Ffull-stack-1%2F</url>
      <content type="text"><![CDATA[本文将包括以下内容: 创建一个Express应用 使用npm和package.json管理应用依赖 调整Express工程结构到MVC架构 Route和Controller概念分离 创建新的Node模块(module) 使用Git在线部署Express应用到Heroku 在进行一切操作之前, 需要先安装好Node.js, 对于*nix用户来说, 直接下载解压, 并添加到环境变量中即可完成安装. 首先从Express着手, Express是构建在Node之上的web应用框架. 使用package.json定义依赖每个Node应用的根目录都有一个文件叫做package.json, 用来记录Node应用的依赖, 例如: 1234567&#123; ... "depencencies": &#123; "express": "~4.9.0" ... &#125;&#125; 其中”~”表示使用最近的patch版本, 推荐使用. 使用npm安装Node依赖工程范围的依赖在和package.json相同的目录层级运行以下指令即可: 1$ npm install 这会将所有的依赖(包括间接依赖)下载到node_modules文件夹内. 如果后期你想向工程中追加依赖, 只需要运行以下指令: 1$ npm install &lt;package-name&gt; --save 以上指令完成了两步操作: 将指定package下载到node_modules文件夹; 将依赖条目追加到package.json文件内. 全局范围的依赖一些通用的依赖需要安装成全局依赖, 例如express generator: 1$ npm install -g express-generator 依赖会被安装到以下路径: ${NODE_HOME}/lib/node_modules/express-generator 创建并启动一个Express工程 新建一个文件夹 在文件夹内运行express npm install按照package.json的定义安装所有依赖 npm start启动程序, 浏览器访问localhost:3000即可. Express的用户请求处理逻辑如下图所示 重启一个Node应用 如果你修改了服务端的Node代码, 那么需要停止应用运行, 编译并重新启动 重启应用的方法有两种, 一种是从启动应用的控制台ctrl+c, 然后npm start, 另一种方法是使用nodemon, nodemom是Node应用的监控程序, 能够简化Node应用的开发. 安装方法如下: 1$ npm install -g nodemon 然后使用nodemon指令代替npm start启动应用程序. 如果你只是修改了Jade模板, CSS文件, 或者客户端的js代码, 无需重新启动应用 调整Express工程结构到MVC模式首先在根目录下新创建一个app_server文件夹, 将根目录下的routes和views文件夹移到里面: 然后更改app.js文件, 将两者重新定位到新的位置. 具体的来说就是将原来的 123app.set('views', path.join(__dirname, 'views'));var index = require('./routes/index');var users = require('./routes/users'); 变更为 123app.set('views', path.join(__dirname, 'app_server', 'views'));var index = require('./app_server/routes/index');var users = require('./app_server/routes/users'); Node模块(module)的生成与使用举个例子, 现在我们有a.js和b.js两个文件, 假设现在它们在同级目录下, 我们想在b.js文件中调用a.js中定义的变量或函数. 下面是a.js文件的内容 123module.exports.logThis = function(message) &#123; console.log(message);&#125; 上述代码将logThis变量(函数)暴露出来, 供其他模块使用, 经过这样设定后我们就可以在b.js中如下调用 12var myModule = require("./a")myModule.logThis("It works!") 需要注意的一点是, require()方法并不需要加后缀, 它会自动依以下顺序搜索: 寻找同名js文件 寻找同名文件夹下的index.js文件 Bootstrap安装 首先下载Bootstrap发行版, 解压并添加到Express工程下的public目录(public目录是用于存放静态资源的目录)下的bootstrap目录(需新建). 由于Bootstrap依赖jquery, 所以我们还要下载jquery, 从这里下载, 注意下载完整版的, 不要下载slim版的, 点击之后, 会跳出一个代码页面, 直接拷贝全部, 然后保存在public/javascript/jquery-&lt;具体的版本.min.js文件中即可. 清空Express默认的样式. 具体的来讲, 就是清空public/stylesheet/style.css文件中的内容 安装Bootstrap主题这里以Amelia主题为例, 从这里下载, 将解压得到的amelia.bootstrap.css和amelia.bootstrap.min.css拷贝到Express工程下的public/bootstrap/css文件夹下. Jade模板的使用Jade模板的使用原则是: 设计一系列的模板布局, 然后让其他文件去扩展 这里我们来看一个例子, 下面分别是layout.jade和index.jade文件的内容: 1234extend layoutblock content h1= title p Welcome to #&#123;title&#125; 上面代码的意思是index.jade扩展了layout.jade, block content是layout.jade中声明的一个html填充块, 这里向里面填充了一个&lt;h1&gt;和一个&lt;p&gt;. 下面让我们来看一下layout.jade. 123456789doctype htmlhtml head title= title link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/style.css&apos;) body block content script(src=&apos;/javascript/jquery-3.1.1.min.js&apos;) script(src=&apos;/bootstrap/js/bootstrap.min.js&apos;) layout.jade除了用于定义html的模板, 还用来进行css和js脚本的连接, 注意: js脚本放在页面最下面有利于提升网页的加载速度. 此外, 第一行设置的viewport有利于页面能够在移动设备上良好的缩放. 到此, 使用Bootstrap的Amelia主题之后的显示效果如下: 使用Heroku进行网站的对外在线演示将网站托管到在线平台上的意义是: 可以便利的进行跨浏览器的测试, 跨设备测试, 并且能够向同事和合作伙伴快速展示与交流开发阶段性进展. 类似的平台服务还有Google Cloud Platform, Nodejitsu, OpenShift等. 安装Heroku 从这里注册一个免费账号 下载Heroku toolbelt, 或者直接使用以下指令在Ubuntu中下载 1$ wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh 触发安装 1$ heroku --version 验证安装成果 1234$ heroku --versionheroku-toolbelt/3.43.15 (x86_64-linux) ruby/1.9.3heroku-cli/5.5.6-a9ddee4 (linux-amd64) go1.7.4You have no installed plugins. 登陆(实际上完成了类似ssh密钥对生成并上传公钥的工作) 1$ heroku login 使用Heroku提交Node.js应用 首先需要保证云端的运行环境与本地开发环境一致 具体的是在package.json中添加一个engines配置块, 指明node和npm的版本, 如果不清楚的话, 还是确认一下比较好: 12$ node --version$ npm --version 下面是示例的package.json文件: 123456789&#123; "name": "Loc8r" ... "engines": &#123; "node": "~4.6.0", "npm": "~2.15.9" &#125;, ...&#125; 创建一个云端启动脚本 具体来说就是创建一个启动脚本, 指明我们应用的类型以及启动指令, 对于Node.js应用来说, 需要在应用的根目录下创建一个名为Procfile的文件, 示例内容如下: 1web: npm start 使用heroku local进行本地验证 heroku local的前身是foreman, 但是现在的heroku toolbelt中已经用前者替换掉了了后者, 详见如下官方通知 heroku local工具是用来在提交应用前进行本地验证的, 使用heroku local启动应用前需要先关闭本地应用, 然后使用以下指令启动: 1$ heroku local web 程序成功启动后会监听在5000端口, 我们可以通过localhost:5000来访问, 显示效果应与之前本地直接运行相同. 将应用托管到Heroku 首先需要初始化一个git仓库, 添加.gitignore文件, 推荐使用这里自动生成(键入Node即可). 然后在云端创建一个heroku应用容器(隐式完成了本地仓库的关联) 123$ heroku createCreating app... done, ⬢ sheltered-everglades-85543https://sheltered-everglades-85543.herokuapp.com/ | https://git.heroku.com/sheltered-everglades-85543.git 推送到远程仓库 1$ git push heroku master 在heroku云端用测试机(dyno)来运行部署的程序 每位用户都会免费获得一个可用的web测试机, 使用如下指令来开启它 12$ heroku ps:scale web=1Scaling dynos... done, now running web at 1:Free 在线浏览部署情况 1$ heroku open 自动在云端的网址上看到部署的应用的情况 之后修改了应用代码后, 只需要push到heroku容器的master分支, 就会自动更新并部署.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB知识点汇总]]></title>
      <url>%2F2016%2F12%2F08%2Finterview-mongo%2F</url>
      <content type="text"><![CDATA[MongoDB适用场景 日志 每个应用环境都有不同的日志信息, 文档型数据库没有固定的模式, 很适合用来存储日志. (TODO 待补充) MongoDB的特点无模式降低在OOP中使用的阻力, 适用于保存对象. 因为一个对象只需要串行化成一个JSON就可以传递给MongoDB了, 不需要进行属性映射或者类型映射. 受限集合与TTL索引受限集合在达到存储上限的时候, 旧文档会自动清除. 还可以通过tail一个受限集合, 来获取最新的数据. 如果想让数据过期, 可以通过创建TTL索引, 来显式指定一个数据的过期时间. 地理空间查询MongoDB支持2d索引, 可以方便的保存geoJSON或者x和y坐标到文档, 通过$near或者$within操作来进行附近或者区域数据. 事务MongoDB不支持事务(TODO 待补充) 如何理解MongoDB集群的高可用性详见:MongoDB高可用性 MongoDB和mysql的优劣势对比 MySQL适合于传统的对关联要求高的方面, 而对于MongoDB来说, 关联一般做成内联的.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基础知识]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-basic%2F</url>
      <content type="text"><![CDATA[文档文档就是键值对的一个有序集, 相当于传统关系型数据库的一行. 比如map, hash或者dict(在JavaScript里表示为对象). 其中键是字符串类型的, 值可以是任意类型的. 文档中的键值对是有序的. 集合集合就是一组文档, 相当于一张表. 虽然集合里面可以放置任何类型的文档, 但是还是建议分开存储(后面解释). 集合可以拥有子集合, 使用”.”来界定命名空间. 例如: 一个拥有博客功能的应用可能包含两个集合, 分别是blog.posts和blog.authors. 很多mongodb工具都使用了子集合, 因为使用它来组织数据非常高效(后面介绍), 值得推荐. 数据库多个集合组成数据库. 将数据库的名字添加到集合的名字前, 可以得到集合的全限定名. 例如cms.blog.post表示cms数据库中的blog.posts集合. MongoDB启动与监控首先创建默认的数据存储目录 1$ mkdir -p /data/db 通过以下命令启动(需要保证mongodb在环境变量中) 1$ mongod 当服务器运行后, 会监听在27017端口. 同时还会启动一个基本的http服务器, 可以通过http://localhost:28017来访问数据库的管理信息. MongoDB shell首先要保证MongoDB实例已启动, 然后通过以下命令进行连接 1$ mongo MongoDB shell是一个完整的JavaScript解释器, 也就是可以运行任意的JavaScript指令. 它也是一个独立的MongoDB客户端, 在启动时会连到test数据库, 并且将数据库的连接赋值为全局变量db, 可以通过db来访问MongoDB中的数据库. 如果需要切换数据库, 只需要运行如下指令: 12&gt; use foobarswitched to db foobar 连接远程数据库1$ mongo &lt;host-ip/host-name&gt;:&lt;port&gt;/&lt;dbname&gt; 不连接数据库进行启动1$ mongo --nodb 如果后面需要重新连接到数据库的话, 使用如下指令: 12&gt; conn = new Mongo("some-host:port")&gt; db = conn.getDB("dbname") 列出所有数据库12345&gt; show dbsLoc8r 0.000GBadmin 0.000GBlocal 0.000GBtest 0.005GB 列出数据库中的所有集合(collection)12&gt; show collectionsstartup_log 查询1&gt; db.startup_log.find() 如果在find()中不指定查询参数的话, 默认是查询所有内容, 但是不用担心, MongoDB会分页返回结果给我们. 如果嫌弃结果显示的不美观, 可以指定pretty()来进行换行显示 1&gt; db.startup_log.find().pretty() 删除指定collection1&gt; db.collectionname.drop()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引-初级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index%2F</url>
      <content type="text"><![CDATA[为什么要使用索引下面以一个例子来说明: 假设我们现在有一个100w条的文档数据, 每个文档数据都包含一个username字段, 其值从user1到user1000000, 假定我们希望通过username进行查询. 1&gt; db.user.find(&#123;username: "user101"&#125;) 我们可以在查询的同时开启操作的监控: 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 1000000, "nscannedObjects": 1000000, "millis": 721, ...&#125; 我们可以看到集合中的所有的文档都会被扫描, 因为无法确定集合中的username字段是唯一的. 如果不使用索引的话, 我们可以通过限制查询结果数量来强制mongo找到符合条件的结果即返回. 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 102, "nscannedObjects": 102, "millis": 2, ...&#125; 虽然上面的查询扫描数量减少了, 但是如果要查找的是user999999就还是需要整体扫描一遍. 创建索引如下是按照username字段正序(指定为1)创建索引. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;) 由于创建索引比较费时, 可以通过在另一个shell中执行db.currentOp()或者是检查mongod的日志来 查看索引创建进度. 当索引创建完成后, 再次执行最初的查询. 12345678&gt; db.user.find(&#123;"username": "user101"&#125;).explain()&#123; ... "nscanned": 1, "nscannedObjects": 1, "millis": 3, ...&#125; 使用了索引之后查询几乎可以瞬间完成, 但是每次写操作(包括插入, 更新和删除)将会耗费更多时间. 因为要同时更新文档和索引. 所以实际使用中, 不应该拥有两个以上的索引. 复合索引就是在多个字段上创建一个索引, 注意索引间是有顺序的, 例如: 1&gt; db.user.ensureIndex(&#123;"age": 1, "username": 1&#125;) 实际创建的索引会先按照age字段排序, 然后按照username字段排序. 这个索引主要有以下三种使用方法: 点查询1&gt; db.user.find(&#123;"age": 21&#125;).sort(&#123;"username": -1&#125;) 由于之前我们创建了符合索引, 所以首先可以直接定位到age为21的记录, 然后由于这些记录是按照username正序排列好的, 所以可以直接用sort()方法指定逆序输出, 不需要额外的时间开销. 多值查询1&gt; db.user.find(&#123;"age": &#123;"$gte": 21, $"lte": 30&#125;&#125;).sort(&#123;"username": 1&#125;) 由于这个查询跨了多个age值, 虽然在每个age值内username是有序的, 但是整体来看是无序的, 所以需要在内存中先对结果进行排序, 然后才能返回. 所以说这个查询通常会较为低效. 隐式索引我们现在创建了一个{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引, 实际上我们同时也获得了一个{&quot;age&quot;: 1}索引, 也就是说: 如果我们有一个N个键的索引, 那么想到哪关于我们同时获得了这N个键的前缀组成的索引. 复合索引创建的准则 用于精确匹配的字段, 放在索引的前面;用于范围匹配的字段放在最后. 假设现在要使用{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引进行查询, 构造以下查询: 1&gt; db.user.find(&#123;"age": 47, "username": &#123;"$gt": "user5", "$lt": "user8"&#125;&#125;).explain() 在基数比较高的键上建立索引, 至少要把基数高的键放在复合索引的前面 因为一个字段的基数(也就是取值的可能值)越高, 这个键上的索引就越有用. 举个例子, 比如我们在gender字段上创建索引, 那么只能将搜索空间缩小到50%左右; 而如果我们在name字段上创建索引, 那么结果集就会非常小, 查询时间大大缩短. 何时不应该使用索引通常来说, 当查询返回较小的结果集时, 索引会非常高效. 结果集在原集合中所占比例越大, 索引的速度就越慢. 因为索引需要进行两次查找, 一次是查找索引条目, 一次是根据索引去查找文档. 一般来说, 当结果集占原集合30%左右时, 就需要考虑是否直接进行全表扫描来代替索引. 索引类型唯一索引可以在单个字段上或者符合字段上创建唯一索引, 被唯一索引标识的字段在集合中不能重复. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;, &#123;"unique": true&#125;) 稀疏索引唯一索引会对该字段上所有的取值进行索引, 也就是说null也会被视为有值, 所以并不适合于在有缺失值的字段上使用, 而稀疏索引会忽略掉缺失值, 只对该字段存在值的部分文档进行索引. 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"sparse": true&#125;) 当然, 可以与唯一索引结合使用 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"unique": true, "sparse": true&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引--高级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index2%2F</url>
      <content type="text"><![CDATA[固定集合MongoDB中默认的集合是动态创建的, 可以自动增长以容纳更多的数据, 而固定集合类似于循环队列, 当集合满时会自动将最老的文档删除. 固定集合的数据被写入磁盘上的固定空间, 所以写入速度非常快. 固定集合的创建下述指令创建一个10w字节的固定集合 1&gt; db.createCollection("collection_name", &#123;"capped": true, "size": 100000&#125;) TTL索引对于固定集合来讲, 如果需要超时自动移除文档, 那么可以使用TTL索引 1&gt; db.foo.ensureIndex(&#123;"lastUpdated": 1&#125;, &#123;"expireAfterSecs": 60*60*24&#125;) 以上代码设置了超时时间为1天. 地理空间索引MongoDB支持几种类型的地理空间索引. 其中最常用的是2dsphere索引(用于地球表面类型的地图)和2d索引(用于平面地图和时间连续的数据). 2d索引对于非球面的地图(游戏地图, 时间连续的数据等), 可以使用2d索引代替2dsphere. 一个符合2d索引的文档 1234&#123; "name": "Water Temple", "title": [32, 22]&#125; 查询[20, 21]点附近的对象 1&gt; db.hyrule.find(&#123;"title": &#123;"$near": [20, 21]&#125;&#125;) 以[12,25]为圆心, 5为半径, 查询出某个圆形范围内的点 1&gt; db.hyrule.find(&#123;"title": &#123;"$within": &#123;"$center": [[12, 25], 5]&#125;&#125;&#125;) 使用GridFS存储文件GridFS是MongoDB的一种存储机制, 通常用来存储不经常改变但是经常需要连续访问的大型二进制文件.]]></content>
    </entry>

    
  
  
</search>
