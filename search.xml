<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Heroku连接云端MongoDB的方法]]></title>
      <url>%2F2016%2F12%2F11%2Ffull-stack4%2F</url>
      <content type="text"><![CDATA[之前我们已经简单的在Heroku上部署了正在开发的web应用, 现在我们的应用要使用MongoDB数据库, 如何在云端部署一个MongoDB连接呢? 再进一步, 最终我们的目的是生产和开发环境连接不同数据库. 本文将完整叙述整个流程. 注册MongoLab账号我们这里将使用MongoLab, 首先需要注册账号, 相关文档请见这里 创建一个新数据库登陆后按照如下操作 选择single node, sandbox, 注意, 只有特定的区域才有single node节点可选, 需要自己手动试一下哪个可行. 创建成功后的效果 如果没有创建成功, 多半是数据库名称冲突了, 多试几个就好. 点击Name进入数据库, 提示要创建一个用户来使用数据库, 那么我们切换到Users标签, 点击add database user 配置Mongolab数据库连接字符串到heroku的配置文件中 123$ heroku config:set MONGOLAB_URI=mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyhSetting MONGOLAB_URI and restarting ⬢ sheltered-everglades-85543... done, v10... 同步本地开发数据库的测试数据到Mongolab 创建一个临时文件夹, 用于本地开发数据库的备份 1$ mkdir -p ~/tmp/mongodump 备份本地开发数据库 1$ mongodump -h localhost:27017 -d Loc8r -o ~/tmp/mongodump 还原数据到云端数据库 1234$ mongorestore -h ds127958.mlab.com:27958 -d congyh -u &lt;username&gt; -p &lt;password&gt; ~/tmp/mongodump/Loc8r...2016-12-11T12:40:06.685+0800 finished restoring congyh.locations (3 documents)2016-12-11T12:40:06.685+0800 done 检查数据还原情况 首先使用mongo shell连接到远程数据库 123456$ mongo ds127958.mlab.com:27958/congyh -u &lt;username&gt; -p &lt;password&gt;MongoDB shell version v3.4.0connecting to: mongodb://ds127958.mlab.com:27958/congyhMongoDB server version: 3.2.11WARNING: shell and server versions do not matchrs-ds127958:PRIMARY&gt; 列出数据 12&gt; show collections&gt; db.locations.find() 让应用根据环境自动选择连接的数据库经过以上操作, 我们获得了一个和本地开发数据库同步的云端数据库, 由于我们的应用同时在本地开发和Heroku部署, 需要让应用根据环境自动连接到正确的数据库. 设置NODE_ENV环境变量 首先需要将heroku上部署的应用切换到production环境(注意: 要在应用根目录下执行指令). 123$ heroku config:set NODE_ENV=productionSetting NODE_ENV and restarting ⬢ sheltered-everglades-85543... done, v11NODE_ENV: production 更改应用源码中数据库连接的设置 12345var dbURI = 'mongodb://localhost/Loc8r';if (process.env.NODE_ENV === 'production') &#123; dbURI = process.env.MONGOLAB_URI;&#125;mongoose.connect(dbURI); 本地测试连接到本地开发数据库和Mongolab数据库 首先测试连接到本地开发数据库 12$ nodemonMongoose connected to mongodb://localhost/Loc8r 然后测试连接到Mongolab数据库 12$ NODE_ENV=production MONGOLAB_URI=mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh nodemonMongoose connected to mongodb:///&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh 测试成功后, 将应用推送到Heroku仓库部署 123$ git add .$ git commit -am "add mongolab support"$ git push heroku master 通过检查heroku云端应用日志, 验证数据库连接情况 123$ heroku logs...2016-12-11T05:08:18.152506+00:00 app[web.1]: Mongoose connected to mongodb://&lt;dbuser&gt;:&lt;dbpassword&gt;@ds127958.mlab.com:27958/congyh 以上, 就完成了生产和开发环境连接不同数据库的配置.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[百度地图静态图API使用指南]]></title>
      <url>%2F2016%2F12%2F10%2Fbaidumap-static-api%2F</url>
      <content type="text"><![CDATA[本文的目的是根据经纬度获取一张指定大小的静态地图, 用于内嵌在网页中. 步骤1: 申请百度开发者账号 这部没什么好讲的, 和申请百度账号相仿 步骤2: 申请一个密钥 点击API控制台-&gt;开发-&gt;静态图API 点击获取密钥, 勾选全部权限, 然后设置访问网址为0.0.0.0/0. 点击API控制台, 这里可以看见先前生成的密钥 步骤3: 在应用中嵌入图片, url指定为符合静态图API的网址 这里举一个示例网址 http://api.map.baidu.com/staticimage/v2?ak=这里是你自己的ak&amp;mcode=666666&amp;center=116.403874,39.914888&amp;width=400&amp;height=350&amp;zoom=11&amp;markers=116.403874,39.914888 嵌在程序中会达到以下效果 其中 ak是刚才的密钥 center是经纬度 markers是地图标注的经纬度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mongoose+Mongo+Express]]></title>
      <url>%2F2016%2F12%2F10%2Ffull-stack3%2F</url>
      <content type="text"><![CDATA[Mongoose是在Express应用与MongoDB之间, 负责两者的连接与数据交换. 使用Mongoose我们可以方便的定义数据结构. Mongoose的地位如下图所示 添加Mongoose到应用中Mongoose是一个npm模块, 可以像其他模块一样添加到程序中, 并写入依赖 1$ npm install --save mongoose 配置Mongoose到应用范围内在Express应用范围导入mongoose连接, 应在工程根目录的app.js中进行引入, 这里由于我们使用的是MVC架构, 所以应该将数据库部分的管理归类在models文件夹中. 我们在目录结构如下 123456789app.jsapp_server├── controllers├── models └──db.js├── routes└── views └── _includes index.js 我们在db.js中添加如下 1var mongoose = require('mongoose') 然后在app.js中新增如下配置 1require('./app_server/models/db') 由于我们不需要从db.js模块暴露方法, 不需要为require操作指定变量. 使用Mongoose指定连接连接格式如下 如果我们是连接到本地mongo实例, 那么username, password, port字段都是可以省略的. 继续向db.js模块添加如下语句, 完成到本地mongo实例的连接 12var dbURI = 'mongodb://localhost/Loc8r';mongoose.connect(dbURI); 注: 关于如何启动本地mongo实例, 请见我的文章:MongoDB基础知识 监控mongoose连接事件现在我们想监控连接成功, 连接失败, 连接断开三个事件, 只需要向db.js追加如下代码 123456789mongoose.connection.on('connected', function() &#123; console.log('Mongoose connected to ' + dbURI);&#125;);mongoose.connection.on('error', function(err) &#123; console.log('Mongoose connection error: ' + err);&#125;);mongoose.connection.on('disconnected', function() &#123; console.log('Mongoose disconnected');&#125;); 关闭Mongoose连接由于node应用停止时, mongo实例的连接池不会自动关闭, 下面我们将编写代码, 在Node应用退出的时候, 自动关闭mongo连接池. Node应用退出前, 根据你启动应用的方式不同, 会释放出不同的信号, 如果我们想在任何场景都使Node应用退出时自动关闭连接, 则需要捕获所有的信号类型. 为此, 我们首先要定义一个通用的关闭连接的函数, 在里面完成mongoose连接的关闭. 1234567891011121314/** * 关闭mongoose连接 * &lt;p&gt; * 这里定义了一个闭包, 外层的作用是为里层的函数提供'环境', 这里也就是msg参数. * 否则mongoose.connection.close本身是不接收带参数的回调函数的 * @param msg 触发关闭的事件类型 * @param callback 负责进行Node应用的关闭 */var gracefulShutdown = function (msg, callback) &#123; mongoose.connection.close(function () &#123; console.log('Mongoose disconnected through' + msg); callback(); &#125;);&#125;; 类型1: SIGINT 此种信号产生在使用npm start指令启动的node应用停止前, 现在我们要在应用捕获到这个信号的时候先执行mongoose的关闭逻辑. 12345process.on('SIGINT', function () &#123; gracefulShutdown('app termination', function () &#123; process.exit(0); &#125;)&#125;); 类型2: SIGTERM 此种信号产生在Heroku关闭应用进程前, 同样, 我们要在捕获到这个信号的时候先关闭mongoose连接. 12345process.on('SIGTERM', function () &#123; gracefulShutdown('Heroku app shutdown', function () &#123; process.exit(0); &#125;)&#125;); 类型3: SIGUSR2 此种信号产生是用来通知nodemon进程来重启node应用的, 由于nodemon进程本身也依赖这个信号来进行node应用的重启逻辑, 所以我们不应该完全截断, 而是应该在捕获信号, 完成关闭mongoose逻辑之后再手动发出一个同样的信号, 通知nodemon完成应用的重启. 并且仅捕获此信号一次, 防止第二次手动释放的信号又被应用进程截获. 12345678// 注意, 这里与上面的程序有两点不同, 一个是只捕获一次信号// 另一点是这里用的是kill, 要求立即结束程序, 并要重新释放同样的信号// 供nodemon使用process.once('SIGUSR2', function () &#123; gracefulShutdown('nodemon restart', function () &#123; process.kill(process.pid, 'SIGUSR2'); &#125;)&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Jade模板中变量的使用]]></title>
      <url>%2F2016%2F12%2F10%2Ffull-stack2%2F</url>
      <content type="text"><![CDATA[形式1: JavaScript行内代码 1h1= pageHeader.title 形式2: 插值 1some text #&#123;pageHeader.strapline&#125; 注意: 以上两种做法都会将html代码直接转为文本输出(出于安全考虑), 如果想保留原来的html标签输出, 则使用!=和!{}的形式即可 形式3: 使用JavaScript代码段 12- for (var i = 1; i &lt; location.rating; i++) &lt;本行为Jade代码&gt; 注意: 整体上来看, 与JavaScript语法相当像, 不过现在不是用大括号标识代码块, 而是用缩进来标志. if语句不需要用”-“连接 形式4: 使用mixin定义可重用的代码段 无参数的mixin定义 12mixin welcome p Welcome 调用mixin的语法为 1+welcome 下面是带参数的mixin定义 123mixin outputRating(rating) - for (var i = 1; i &lt;= rating; i++) &lt;这里是jade代码&gt; 调用带参数的mixin语法 1+outputRating(&lt;实参&gt;) 如果我们想要在其他文件中使用在本文件中定义的mixin, 通过include关键字加路径实现. 例如, 现在我们的目录层级如下所示: 123├── _includes│ └── sharedHTMLfunctions.jade└── locations-list.jade 我们想通过location-list.jade文件来引用_includes/sharedHTMLfunctions.jade中的mixin, 可以如下使用: 123include _includes/sharedHTMLfunctions...+outputRating(&lt;实参&gt;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从零构建部署Node.js+Express+Bootstrap Web应用]]></title>
      <url>%2F2016%2F12%2F09%2Ffull-stack-1%2F</url>
      <content type="text"><![CDATA[本文将包括以下内容: 创建一个Express应用 使用npm和package.json管理应用依赖 调整Express工程结构到MVC架构 Route和Controller概念分离 创建新的Node模块(module) 使用Git在线部署Express应用到Heroku 在进行一切操作之前, 需要先安装好Node.js, 对于*nix用户来说, 直接下载解压, 并添加到环境变量中即可完成安装. 首先从Express着手, Express是构建在Node之上的web应用框架. 使用package.json定义依赖每个Node应用的根目录都有一个文件叫做package.json, 用来记录Node应用的依赖, 例如: 1234567&#123; ... "depencencies": &#123; "express": "~4.9.0" ... &#125;&#125; 其中”~”表示使用最近的patch版本, 推荐使用. 使用npm安装Node依赖工程范围的依赖在和package.json相同的目录层级运行以下指令即可: 1$ npm install 这会将所有的依赖(包括间接依赖)下载到node_modules文件夹内. 如果后期你想向工程中追加依赖, 只需要运行以下指令: 1$ npm install &lt;package-name&gt; --save 以上指令完成了两步操作: 将指定package下载到node_modules文件夹; 将依赖条目追加到package.json文件内. 全局范围的依赖一些通用的依赖需要安装成全局依赖, 例如express generator: 1$ npm install -g express-generator 依赖会被安装到以下路径: ${NODE_HOME}/lib/node_modules/express-generator 创建并启动一个Express工程 新建一个文件夹 在文件夹内运行express npm install按照package.json的定义安装所有依赖 npm start启动程序, 浏览器访问localhost:3000即可. Express的用户请求处理逻辑如下图所示 重启一个Node应用 如果你修改了服务端的Node代码, 那么需要停止应用运行, 编译并重新启动 重启应用的方法有两种, 一种是从启动应用的控制台ctrl+c, 然后npm start, 另一种方法是使用nodemon, nodemom是Node应用的监控程序, 能够简化Node应用的开发. 安装方法如下: 1$ npm install -g nodemon 然后使用nodemon指令代替npm start启动应用程序. 如果你只是修改了Jade模板, CSS文件, 或者客户端的js代码, 无需重新启动应用 调整Express工程结构到MVC模式首先在根目录下新创建一个app_server文件夹, 将根目录下的routes和views文件夹移到里面: 然后更改app.js文件, 将两者重新定位到新的位置. 具体的来说就是将原来的 123app.set('views', path.join(__dirname, 'views'));var index = require('./routes/index');var users = require('./routes/users'); 变更为 123app.set('views', path.join(__dirname, 'app_server', 'views'));var index = require('./app_server/routes/index');var users = require('./app_server/routes/users'); Node模块(module)的生成与使用举个例子, 现在我们有a.js和b.js两个文件, 假设现在它们在同级目录下, 我们想在b.js文件中调用a.js中定义的变量或函数. 下面是a.js文件的内容 123module.exports.logThis = function(message) &#123; console.log(message);&#125; 上述代码将logThis变量(函数)暴露出来, 供其他模块使用, 经过这样设定后我们就可以在b.js中如下调用 12var myModule = require("./a")myModule.logThis("It works!") 需要注意的一点是, require()方法并不需要加后缀, 它会自动依以下顺序搜索: 寻找同名js文件 寻找同名文件夹下的index.js文件 Bootstrap安装 首先下载Bootstrap发行版, 解压并添加到Express工程下的public目录(public目录是用于存放静态资源的目录)下的bootstrap目录(需新建). 由于Bootstrap依赖jquery, 所以我们还要下载jquery, 从这里下载, 注意下载完整版的, 不要下载slim版的, 点击之后, 会跳出一个代码页面, 直接拷贝全部, 然后保存在public/javascript/jquery-&lt;具体的版本.min.js文件中即可. 清空Express默认的样式. 具体的来讲, 就是清空public/stylesheet/style.css文件中的内容 安装Bootstrap主题这里以Amelia主题为例, 从这里下载, 将解压得到的amelia.bootstrap.css和amelia.bootstrap.min.css拷贝到Express工程下的public/bootstrap/css文件夹下. Jade模板的使用Jade模板的使用原则是: 设计一系列的模板布局, 然后让其他文件去扩展 这里我们来看一个例子, 下面分别是layout.jade和index.jade文件的内容: 1234extend layoutblock content h1= title p Welcome to #&#123;title&#125; 上面代码的意思是index.jade扩展了layout.jade, block content是layout.jade中声明的一个html填充块, 这里向里面填充了一个&lt;h1&gt;和一个&lt;p&gt;. 下面让我们来看一下layout.jade. 123456789doctype htmlhtml head title= title link(rel=&apos;stylesheet&apos;, href=&apos;/stylesheets/style.css&apos;) body block content script(src=&apos;/javascript/jquery-3.1.1.min.js&apos;) script(src=&apos;/bootstrap/js/bootstrap.min.js&apos;) layout.jade除了用于定义html的模板, 还用来进行css和js脚本的连接, 注意: js脚本放在页面最下面有利于提升网页的加载速度. 此外, 第一行设置的viewport有利于页面能够在移动设备上良好的缩放. 到此, 使用Bootstrap的Amelia主题之后的显示效果如下: 使用Heroku进行网站的对外在线演示将网站托管到在线平台上的意义是: 可以便利的进行跨浏览器的测试, 跨设备测试, 并且能够向同事和合作伙伴快速展示与交流开发阶段性进展. 类似的平台服务还有Google Cloud Platform, Nodejitsu, OpenShift等. 安装Heroku 从这里注册一个免费账号 下载Heroku toolbelt, 或者直接使用以下指令在Ubuntu中下载 1$ wget -O- https://toolbelt.heroku.com/install-ubuntu.sh | sh 触发安装 1$ heroku --version 验证安装成果 1234$ heroku --versionheroku-toolbelt/3.43.15 (x86_64-linux) ruby/1.9.3heroku-cli/5.5.6-a9ddee4 (linux-amd64) go1.7.4You have no installed plugins. 登陆(实际上完成了类似ssh密钥对生成并上传公钥的工作) 1$ heroku login 使用Heroku提交Node.js应用 首先需要保证云端的运行环境与本地开发环境一致 具体的是在package.json中添加一个engines配置块, 指明node和npm的版本, 如果不清楚的话, 还是确认一下比较好: 12$ node --version$ npm --version 下面是示例的package.json文件: 123456789&#123; "name": "Loc8r" ... "engines": &#123; "node": "~4.6.0", "npm": "~2.15.9" &#125;, ...&#125; 创建一个云端启动脚本 具体来说就是创建一个启动脚本, 指明我们应用的类型以及启动指令, 对于Node.js应用来说, 需要在应用的根目录下创建一个名为Procfile的文件, 示例内容如下: 1web: npm start 使用heroku local进行本地验证 heroku local的前身是foreman, 但是现在的heroku toolbelt中已经用前者替换掉了了后者, 详见如下官方通知 heroku local工具是用来在提交应用前进行本地验证的, 使用heroku local启动应用前需要先关闭本地应用, 然后使用以下指令启动: 1$ heroku local web 程序成功启动后会监听在5000端口, 我们可以通过localhost:5000来访问, 显示效果应与之前本地直接运行相同. 将应用托管到Heroku 首先需要初始化一个git仓库, 添加.gitignore文件, 推荐使用这里自动生成(键入Node即可). 然后在云端创建一个heroku应用容器(隐式完成了本地仓库的关联) 123$ heroku createCreating app... done, ⬢ sheltered-everglades-85543https://sheltered-everglades-85543.herokuapp.com/ | https://git.heroku.com/sheltered-everglades-85543.git 推送到远程仓库 1$ git push heroku master 在heroku云端用测试机(dyno)来运行部署的程序 每位用户都会免费获得一个可用的web测试机, 使用如下指令来开启它 12$ heroku ps:scale web=1Scaling dynos... done, now running web at 1:Free 在线浏览部署情况 1$ heroku open 自动在云端的网址上看到部署的应用的情况 之后修改了应用代码后, 只需要push到heroku容器的master分支, 就会自动更新并部署.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB基础知识]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-basic%2F</url>
      <content type="text"><![CDATA[文档文档就是键值对的一个有序集, 相当于传统关系型数据库的一行. 比如map, hash或者dict(在JavaScript里表示为对象). 其中键是字符串类型的, 值可以是任意类型的. 文档中的键值对是有序的. 集合集合就是一组文档, 相当于一张表. 虽然集合里面可以放置任何类型的文档, 但是还是建议分开存储(后面解释). 集合可以拥有子集合, 使用”.”来界定命名空间. 例如: 一个拥有博客功能的应用可能包含两个集合, 分别是blog.posts和blog.authors. 很多mongodb工具都使用了子集合, 因为使用它来组织数据非常高效(后面介绍), 值得推荐. 数据库多个集合组成数据库. 将数据库的名字添加到集合的名字前, 可以得到集合的全限定名. 例如cms.blog.post表示cms数据库中的blog.posts集合. MongoDB启动与监控首先创建默认的数据存储目录 1$ mkdir -p /data/db 通过以下命令启动(需要保证mongodb在环境变量中) 1$ mongod 当服务器运行后, 会监听在27017端口. 同时还会启动一个基本的http服务器, 可以通过http://localhost:28017来访问数据库的管理信息. MongoDB shell首先要保证MongoDB实例已启动, 然后通过以下命令进行连接 1$ mongo MongoDB shell是一个完整的JavaScript解释器, 也就是可以运行任意的JavaScript指令. 它也是一个独立的MongoDB客户端, 在启动时会连到test数据库, 并且将数据库的连接赋值为全局变量db, 可以通过db来访问MongoDB中的数据库. 如果需要切换数据库, 只需要运行如下指令: 12&gt; use foobarswitched to db foobar 连接远程数据库1$ mongo &lt;host-ip/host-name&gt;:&lt;port&gt;/&lt;dbname&gt; 不连接数据库进行启动1$ mongo --nodb 如果后面需要重新连接到数据库的话, 使用如下指令: 12&gt; conn = new Mongo("some-host:port")&gt; db = conn.getDB("dbname") 列出所有数据库12345&gt; show dbsLoc8r 0.000GBadmin 0.000GBlocal 0.000GBtest 0.005GB 列出数据库中的所有集合(collection)12&gt; show collectionsstartup_log 查询1&gt; db.startup_log.find() 如果在find()中不指定查询参数的话, 默认是查询所有内容, 但是不用担心, MongoDB会分页返回结果给我们. 如果嫌弃结果显示的不美观, 可以指定pretty()来进行换行显示 1&gt; db.startup_log.find().pretty() 删除指定collection1&gt; db.collectionname.drop()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引-初级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index%2F</url>
      <content type="text"><![CDATA[为什么要使用索引下面以一个例子来说明: 假设我们现在有一个100w条的文档数据, 每个文档数据都包含一个username字段, 其值从user1到user1000000, 假定我们希望通过username进行查询. 1&gt; db.user.find(&#123;username: "user101"&#125;) 我们可以在查询的同时开启操作的监控: 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 1000000, "nscannedObjects": 1000000, "millis": 721, ...&#125; 我们可以看到集合中的所有的文档都会被扫描, 因为无法确定集合中的username字段是唯一的. 如果不使用索引的话, 我们可以通过限制查询结果数量来强制mongo找到符合条件的结果即返回. 12345678&gt; db.user.find(&#123;username: "user101"&#125;).explain()&#123; ... "nscanned": 102, "nscannedObjects": 102, "millis": 2, ...&#125; 虽然上面的查询扫描数量减少了, 但是如果要查找的是user999999就还是需要整体扫描一遍. 创建索引如下是按照username字段正序(指定为1)创建索引. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;) 由于创建索引比较费时, 可以通过在另一个shell中执行db.currentOp()或者是检查mongod的日志来 查看索引创建进度. 当索引创建完成后, 再次执行最初的查询. 12345678&gt; db.user.find(&#123;"username": "user101"&#125;).explain()&#123; ... "nscanned": 1, "nscannedObjects": 1, "millis": 3, ...&#125; 使用了索引之后查询几乎可以瞬间完成, 但是每次写操作(包括插入, 更新和删除)将会耗费更多时间. 因为要同时更新文档和索引. 所以实际使用中, 不应该拥有两个以上的索引. 复合索引就是在多个字段上创建一个索引, 注意索引间是有顺序的, 例如: 1&gt; db.user.ensureIndex(&#123;"age": 1, "username": 1&#125;) 实际创建的索引会先按照age字段排序, 然后按照username字段排序. 这个索引主要有以下三种使用方法: 点查询1&gt; db.user.find(&#123;"age": 21&#125;).sort(&#123;"username": -1&#125;) 由于之前我们创建了符合索引, 所以首先可以直接定位到age为21的记录, 然后由于这些记录是按照username正序排列好的, 所以可以直接用sort()方法指定逆序输出, 不需要额外的时间开销. 多值查询1&gt; db.user.find(&#123;"age": &#123;"$gte": 21, $"lte": 30&#125;&#125;).sort(&#123;"username": 1&#125;) 由于这个查询跨了多个age值, 虽然在每个age值内username是有序的, 但是整体来看是无序的, 所以需要在内存中先对结果进行排序, 然后才能返回. 所以说这个查询通常会较为低效. 隐式索引我们现在创建了一个{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引, 实际上我们同时也获得了一个{&quot;age&quot;: 1}索引, 也就是说: 如果我们有一个N个键的索引, 那么想到哪关于我们同时获得了这N个键的前缀组成的索引. 复合索引创建的准则 用于精确匹配的字段, 放在索引的前面;用于范围匹配的字段放在最后. 假设现在要使用{&quot;age&quot;: 1, &quot;username&quot;: 1}的索引进行查询, 构造以下查询: 1&gt; db.user.find(&#123;"age": 47, "username": &#123;"$gt": "user5", "$lt": "user8"&#125;&#125;).explain() 在基数比较高的键上建立索引, 至少要把基数高的键放在复合索引的前面 因为一个字段的基数(也就是取值的可能值)越高, 这个键上的索引就越有用. 举个例子, 比如我们在gender字段上创建索引, 那么只能将搜索空间缩小到50%左右; 而如果我们在name字段上创建索引, 那么结果集就会非常小, 查询时间大大缩短. 何时不应该使用索引通常来说, 当查询返回较小的结果集时, 索引会非常高效. 结果集在原集合中所占比例越大, 索引的速度就越慢. 因为索引需要进行两次查找, 一次是查找索引条目, 一次是根据索引去查找文档. 一般来说, 当结果集占原集合30%左右时, 就需要考虑是否直接进行全表扫描来代替索引. 索引类型唯一索引可以在单个字段上或者符合字段上创建唯一索引, 被唯一索引标识的字段在集合中不能重复. 1&gt; db.user.ensureIndex(&#123;"username": 1&#125;, &#123;"unique": true&#125;) 稀疏索引唯一索引会对该字段上所有的取值进行索引, 也就是说null也会被视为有值, 所以并不适合于在有缺失值的字段上使用, 而稀疏索引会忽略掉缺失值, 只对该字段存在值的部分文档进行索引. 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"sparse": true&#125;) 当然, 可以与唯一索引结合使用 1&gt; db.ensureIndex(&#123;"email": 1&#125;, &#123;"unique": true, "sparse": true&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MongoDB索引--高级篇]]></title>
      <url>%2F2016%2F12%2F08%2Fmongo-index2%2F</url>
      <content type="text"><![CDATA[固定集合MongoDB中默认的集合是动态创建的, 可以自动增长以容纳更多的数据, 而固定集合类似于循环队列, 当集合满时会自动将最老的文档删除. 固定集合的数据被写入磁盘上的固定空间, 所以写入速度非常快. 固定集合的创建下述指令创建一个10w字节的固定集合 1&gt; db.createCollection("collection_name", &#123;"capped": true, "size": 100000&#125;) TTL索引对于固定集合来讲, 如果需要超时自动移除文档, 那么可以使用TTL索引 1&gt; db.foo.ensureIndex(&#123;"lastUpdated": 1&#125;, &#123;"expireAfterSecs": 60*60*24&#125;) 以上代码设置了超时时间为1天. 地理空间索引MongoDB支持几种类型的地理空间索引. 其中最常用的是2dsphere索引(用于地球表面类型的地图)和2d索引(用于平面地图和时间连续的数据). 2d索引对于非球面的地图(游戏地图, 时间连续的数据等), 可以使用2d索引代替2dsphere. 一个符合2d索引的文档 1234&#123; "name": "Water Temple", "title": [32, 22]&#125; 查询[20, 21]点附近的对象 1&gt; db.hyrule.find(&#123;"title": &#123;"$near": [20, 21]&#125;&#125;) 以[12,25]为圆心, 5为半径, 查询出某个圆形范围内的点 1&gt; db.hyrule.find(&#123;"title": &#123;"$within": &#123;"$center": [[12, 25], 5]&#125;&#125;&#125;) 使用GridFS存储文件GridFS是MongoDB的一种存储机制, 通常用来存储不经常改变但是经常需要连续访问的大型二进制文件.]]></content>
    </entry>

    
  
  
</search>
